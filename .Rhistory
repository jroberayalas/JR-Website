tibble(week = 1:1e5,
island = positions) %>%
mutate(island = factor(island)) %>%
ggplot(aes(x = island)) +
geom_bar() +
labs(title = "Old Metropolis shines in the long run.",
subtitle = "Sure enough, the time the king spent on each island was\nproportional to its population size.") +
theme_ipsum()
tibble(week = 1:1e5,
island = positions) %>%
mutate(island = factor(island)) %>%
ggplot(aes(x = island)) +
geom_histogram() +
labs(title = "Old Metropolis shines in the long run.",
subtitle = "Sure enough, the time the king spent on each island was\nproportional to its population size.") +
theme_ipsum()
tibble(week = 1:1e5,
island = positions) %>%
mutate(island = factor(island)) %>%
ggplot(aes(x = island)) +
geom_histogram(stat = "count") +
labs(title = "Old Metropolis shines in the long run.",
subtitle = "Sure enough, the time the king spent on each island was\nproportional to its population size.") +
theme_ipsum()
tibble(week = 1:1e5,
island = positions) %>%
mutate(island = factor(island)) %>%
ggplot(aes(x = island)) +
geom_bar() +
labs(title = "Old Metropolis shines in the long run.",
subtitle = "Sure enough, the time the king spent on each island was\nproportional to its population size.") +
theme_ipsum()
library(rethinking)
data(rugged)
d <- rugged
detach(package:rethinking)
library(brms)
rm(rugged)
d <-
d %>%
mutate(log_gdp = log(rgdppc_2000))
set.seed(103)
num_weeks <- 1e5
positions <- rep(0, num_weeks)
current   <- 10
for (i in 1:num_weeks) {
# record current position
positions[i] <- current
# flip coin to generate proposal
proposal <- current + sample(c(-1, 1), size = 1)
# now make sure he loops around the archipelago
if (proposal < 1) proposal <- 10
if (proposal > 10) proposal <- 1
# move?
prob_move <- proposal/current
current <- ifelse(runif(1) < prob_move, proposal, current)
}
library(hrbrthemes)
library(tidyverse)
tibble(week = 1:1e5,
island = positions) %>%
filter(week < 101) %>%
ggplot(aes(x = week, y = island)) +
geom_point(shape = 1) +
geom_line() +
scale_x_continuous(breaks = seq(from = 0, to = 100, by = 20)) +
scale_y_continuous(breaks = seq(from = 0, to = 10, by = 2)) +
labs(title = "Behold: The Metropolis algorithm in action!",
subtitle = "The dots show the king's path over the first 100 weeks.") +
theme_ipsum()
tibble(week = 1:1e5,
island = positions) %>%
mutate(island = factor(island)) %>%
ggplot(aes(x = island)) +
geom_bar() +
labs(title = "Old Metropolis shines in the long run.",
subtitle = "Sure enough, the time the king spent on each island was\nproportional to its population size.") +
theme_ipsum()
library(rethinking)
data(rugged)
d <- rugged
detach(package:rethinking)
library(brms)
rm(rugged)
d <-
d %>%
mutate(log_gdp = log(rgdppc_2000))
dd <-
d %>%
filter(complete.cases(rgdppc_2000))
dd.trim <-
dd %>%
select(log_gdp, rugged, cont_africa)
glimpse(dd.trim)
m8.1 <- brm(data = dd.trim,
log_gdp ~ 1 + rugged + cont_africa + rugged:cont_africa,
prior = c(set_prior("normal(0,100)", class = "Intercept"),
set_prior("normal(0,10)", class = "b"),
set_prior("cauchy(0,2)", class = "sigma")))
print(m8.1)
m8.1_4chains_4cores <- brm(data = dd.trim,
log_gdp ~ 1 + rugged + cont_africa + rugged:cont_africa,
prior = c(set_prior("normal(0,100)", class = "Intercept"),
set_prior("normal(0,10)", class = "b"),
set_prior("cauchy(0,2)", class = "sigma")),
chains = 4, cores = 4)
print(m8.1_4chains_4cores)
post <- posterior_samples(m8.1)
str(post)
post <- posterior_samples(m8.1)
glimpse(post)
pairs(m8.1)
install.packages("GGally", dependencies = T)
library(GG)
library(GGally)
post %>%
select(b_Intercept:sigma) %>%
ggpairs()
library(GGally)
post %>%
select(b_Intercept:sigma) %>%
ggpairs() +
labs(subtitle = "My custom pairs plot") +
theme_ipsum()
library(GGally)
post %>%
select(b_Intercept:sigma) %>%
ggpairs()
library(GGally)
post %>%
select(b_Intercept:sigma) %>%
ggpairs() +
labs(subtitle = "Coefficients plot") +
theme_ipsum()
summary(m8.1, loo = T, waic = T)
plot(m8.1)
library(bayesplot)
post <- posterior_samples(m8.1, add_chain = T)
head(post)
library(bayesplot)
post <- posterior_samples(m8.1, add_chain = T)
mcmc_trace(post[, c(1:5, 7)], # We need to include column 7 because that contains the chain info
facet_args = list(ncol = 3),
size = .15) +
labs(title = "My custom trace plots") +
scale_color_ipsum() +
theme_ipsum() +
theme(legend.position = c(.95, .2))
mcmc_acf(post,
pars = c("b_Intercept", "b_rugged", "b_cont_africa", "b_rugged:cont_africa", "sigma"),
lags = 5) +
scale_color_ipsum() +
theme_ipsum()
stancode(m8.1)
m8.1$model
m8.1$fit@stanmodel
?brm
m8.2 <-
brm(data = list(y = c(-1, 1)),
family = gaussian,
y ~ 1,
prior = c(set_prior("uniform(-1e10, 1e10)", class = "Intercept"),
set_prior("uniform(0, 1e10)", class = "sigma")),
inits = list(list(Intercept = 0, sigma = 1),
list(Intercept = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000)
post <- posterior_samples(m8.2, add_chain = T)
mcmc_trace(post[, c(1:2, 4)],
size = .25) +
labs(title = "My version of Figure 8.5.a.",
subtitle = "These trace plots do not look like the fuzzy caterpillars we usually hope for.") +
scale_color_ipsum() +
theme_ipsum() +
theme(legend.position = c(.85, 1.5),
legend.direction = "horizontal")
head(post)
m8.2 <-
brm(data = list(y = c(-1, 1)),
family = gaussian,
y ~ 1,
prior = c(set_prior("uniform(-1e10, 1e10)", class = "Intercept"),
set_prior("uniform(0, 1e10)", class = "sigma")),
inits = list(list(Intercept = 0, sigma = 1),
list(Intercept = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000)
print(m8.2)
post <- posterior_samples(m8.2, add_chain = T)
mcmc_trace(post[, c(1:2, 4)],
size = .25) +
labs(title = "Sick Markov chain",
subtitle = "These trace plots do not look like the fuzzy caterpillars we usually hope for.") +
scale_color_ipsum() +
theme_ipsum() +
theme(legend.position = c(.85, 1.5),
legend.direction = "horizontal")
m8.3 <- brm(data = list(y = c(-1, 1)),
y ~ 1,
prior = c(set_prior("normal(0,10)", class = "Intercept"),
set_prior("cauchy(0,1)"), class = "sigma"),
inits = list(list(Intercept = 0, sigma = 1),
list(Intercept = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000)
m8.3 <- brm(data = list(y = c(-1, 1)),
y ~ 1,
prior = c(set_prior("normal(0,10)", class = "Intercept"),
set_prior("cauchy(0,1)", class = "sigma")),
inits = list(list(Intercept = 0, sigma = 1),
list(Intercept = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000)
print(b8.3)
m8.3 <- brm(data = list(y = c(-1, 1)),
y ~ 1,
prior = c(set_prior("normal(0,10)", class = "Intercept"),
set_prior("cauchy(0,1)", class = "sigma")),
inits = list(list(Intercept = 0, sigma = 1),
list(Intercept = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000)
print(m8.3)
post <- posterior_samples(m8.3, add_chain = T)
mcmc_trace(post[, c(1:2, 4)],
size = .25) +
labs(title = "Healthy Markov chain",
subtitle = "Oh man. This looks so much better.") +
scale_color_ipsum() +
theme_ipsum() +
theme(legend.position = c(.85, 1.5),
legend.direction = "horizontal")
post %>%
select(b_Intercept) %>%
ggplot(aes(x = b_Intercept)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = min(post$b_Intercept),
to = max(post$b_Intercept),
length.out = 50)),
aes(x = x, y = dnorm(x = x, mean = 0, sd = 10)),
color = ipsum_pal()(1), linetype = 2) +
theme_ipsum()
library(gridExtra)
intercept <- post %>%
select(b_Intercept) %>%
ggplot(aes(x = b_Intercept)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = min(post$b_Intercept),
to = max(post$b_Intercept),
length.out = 50)),
aes(x = x, y = dnorm(x = x, mean = 0, sd = 10)),
color = ipsum_pal()(1), linetype = 2) +
theme_ipsum()
sigma <-  post %>%
select(sigma) %>%
ggplot(aes(x = sigma)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = 0,
to = max(post$sigma),
length.out = 50)),
aes(x = x, y = dcauchy(x = x, location = 0, scale = 1)*2),
color = ipsum_pal()(2)[2], linetype = 2) +
coord_cartesian(xlim = c(0, 10)) +
theme_ipsum()
grid.arrange(intercept, sigma)
library(gridExtra)
intercept <- post %>%
select(b_Intercept) %>%
ggplot(aes(x = b_Intercept)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = min(post$b_Intercept),
to = max(post$b_Intercept),
length.out = 50)),
aes(x = x, y = dnorm(x = x, mean = 0, sd = 10)),
color = ipsum_pal()(1), linetype = 2) +
theme_ipsum()
sigma <-  post %>%
select(sigma) %>%
ggplot(aes(x = sigma)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = 0,
to = max(post$sigma),
length.out = 50)),
aes(x = x, y = dcauchy(x = x, location = 0, scale = 1)*2),
color = ipsum_pal()(2)[2], linetype = 2) +
coord_cartesian(xlim = c(0, 10)) +
theme_ipsum()
grid.arrange(intercept, sigma, ncol=2)
m8.3 <- brm(data = list(y = c(-1, 1)),
y ~ 1,
prior = c(set_prior("normal(1,10)", class = "Intercept"),
set_prior("cauchy(0,1)", class = "sigma")),
inits = list(list(Intercept = 0, sigma = 1),
list(Intercept = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000)
print(m8.3)
post <- posterior_samples(m8.3, add_chain = T)
mcmc_trace(post[, c(1:2, 4)],
size = .25) +
labs(title = "Healthy Markov chain",
subtitle = "Oh man. This looks so much better.") +
scale_color_ipsum() +
theme_ipsum() +
theme(legend.position = c(.85, 1.5),
legend.direction = "horizontal")
library(gridExtra)
intercept <- post %>%
select(b_Intercept) %>%
ggplot(aes(x = b_Intercept)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = min(post$b_Intercept),
to = max(post$b_Intercept),
length.out = 50)),
aes(x = x, y = dnorm(x = x, mean = 0, sd = 10)),
color = ipsum_pal()(1), linetype = 2) +
theme_ipsum()
sigma <-  post %>%
select(sigma) %>%
ggplot(aes(x = sigma)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = 0,
to = max(post$sigma),
length.out = 50)),
aes(x = x, y = dcauchy(x = x, location = 0, scale = 1)*2),
color = ipsum_pal()(2)[2], linetype = 2) +
coord_cartesian(xlim = c(0, 10)) +
theme_ipsum()
grid.arrange(intercept, sigma, ncol=2)
library(gridExtra)
intercept <- post %>%
select(b_Intercept) %>%
ggplot(aes(x = b_Intercept)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = min(post$b_Intercept),
to = max(post$b_Intercept),
length.out = 50)),
aes(x = x, y = dnorm(x = x, mean = 0, sd = 10)),
color = ipsum_pal()(1), linetype = 2) +
theme_ipsum()
sigma <-  post %>%
select(sigma) %>%
ggplot(aes(x = sigma)) +
stat_density(geom = "line") +
geom_line(data = data.frame(x = seq(from = 0,
to = max(post$sigma),
length.out = 50)),
aes(x = x, y = dcauchy(x = x, location = 0, scale = 1)*2),
color = ipsum_pal()(2)[2], linetype = 2) +
coord_cartesian(xlim = c(0, 10)) +
theme_ipsum()
grid.arrange(intercept, sigma, ncol=2)
sd(post$sigma)
median(post$sigma)
y <- rcauchy(1e4,0,5)
mu <- sapply( 1:length(y) , function(i) sum(y[1:i])/i )
plot(mu,type="l")
stancode(m8.3)
set.seed(8.4)
y <- rnorm(100, mean = 0, sd = 1)
m8.4 <-
brm(data = list(y = y,
intercept1 = 1,
intercept2 = 1),
family = gaussian,
y ~ 0 + intercept1 + intercept2,
prior = c(set_prior("uniform(-1e10, 1e10)", class = "b"),
set_prior("cauchy(0, 1)", class = "sigma")),
inits = list(list(intercept1 = 0, intercept2 = 0, sigma = 1),
list(intercept1 = 0, intercept2 = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000,
seed = 8.4)
print(m8.4)
post <- posterior_samples(m8.4, add_chain = T)
head(post)
post <- posterior_samples(m8.4, add_chain = T)
mcmc_trace(post[, c(1:3, 5)],
size = .25) +
labs(title = "Trace Plot") +
scale_color_ipsum() +
theme_ipsum() +
theme(legend.position = c(.85, 1.5),
legend.direction = "horizontal")
m8.5 <-
brm(data = list(y = y,
intercept1 = 1,
intercept2 = 1),
family = gaussian,
y ~ 0 + intercept1 + intercept2,
prior = c(set_prior("normal(0, 10)", class = "b"),
set_prior("cauchy(0, 1)", class = "sigma")),
inits = list(list(intercept1 = 0, intercept2 = 0, sigma = 1),
list(intercept1 = 0, intercept2 = 0, sigma = 1)),
chains = 2, iter = 4000, warmup = 1000)
print(m8.5)
post <- posterior_samples(m8.5, add_chain = T)
mcmc_trace(post[, c(1:3, 5)],
size = .25) +
labs(title = "Trace Plot") +
scale_color_ipsum() +
theme_ipsum() +
theme(legend.position = c(.85, 1.5),
legend.direction = "horizontal")
blogdown:::new_post_addin()
blogdown:::new_post_addin()
blogdown:::serve_site()
# Distribution of pebbles
p <- list()
p$A <- c(0,0,10,0,0)
p$B <- c(0,1,8,1,0)
p$C <- c(0,2,6,2,0)
p$D <- c(1,2,4,2,1)
p$E <- c(2,2,2,2,2)
p_norm <- lapply( p , function(q) q/sum(q))
H <- sapply( p_norm , function(q) -sum(ifelse(q==0,0,q*log(q))) )
# Distribution of pebbles
p <- list()
p$A <- c(0,0,10,0,0)
p$B <- c(0,1,8,1,0)
p$C <- c(0,2,6,2,0)
p$D <- c(1,2,4,2,1)
p$E <- c(2,2,2,2,2)
p_norm <- lapply( p , function(q) q/sum(q))
H <- sapply( p_norm , function(q) -sum(ifelse(q==0,0,q*log(q))) )
H
p_norm
# build list of the candidate distributions
p <- list()
p[[1]] <- c(1/4,1/4,1/4,1/4)
p[[2]] <- c(2/6,1/6,1/6,2/6)
p[[3]] <- c(1/6,2/6,2/6,1/6)
p[[4]] <- c(1/8,4/8,2/8,1/8)
# compute expected value of each
sapply( p , function(p) sum(p*c(0,1,1,2)) )
# build list of the candidate distributions
p <- list()
p[[1]] <- c(1/4,1/4,1/4,1/4)
p[[2]] <- c(2/6,1/6,1/6,2/6)
p[[3]] <- c(1/6,2/6,2/6,1/6)
p[[4]] <- c(1/8,4/8,2/8,1/8)
# compute expected value of each
sapply( p , function(p) sum(p*c(0,1,1,2)) )
# compute entropy of each distribution
sapply( p , function(p) -sum( p*log(p) ) )
sim.p <- function(G=1.4) {
x123 <- runif(3)
x4 <- ( (G)*sum(x123)-x123[2]-x123[3] )/(2-G)
z <- sum( c(x123,x4) )
p <- c( x123 , x4 )/z
list( H=-sum( p*log(p) ) , p=p )
}
H <- replicate( 1e5 , sim.p(1.4) )
dens( as.numeric(H[1,]) , adj=0.1 )
sim.p <- function(G=1.4) {
x123 <- runif(3)
x4 <- ( (G)*sum(x123)-x123[2]-x123[3] )/(2-G)
z <- sum( c(x123,x4) )
p <- c( x123 , x4 )/z
list( H=-sum( p*log(p) ) , p=p )
}
H <- replicate( 1e5 , sim.p(1.4) )
plot(density( as.numeric(H[1,]) , adj=0.1 ))
sim.p <- function(G=1.4) {
x123 <- runif(3)
x4 <- ( (G)*sum(x123)-x123[2]-x123[3] )/(2-G)
z <- sum( c(x123,x4) )
p <- c( x123 , x4 )/z
list( H=-sum( p*log(p) ) , p=p )
}
H <- replicate( 1e5 , sim.p(1.4) )
density( as.numeric(H[1,]) , adj=0.1 )
sim.p <- function(G=1.4) {
x123 <- runif(3)
x4 <- ( (G)*sum(x123)-x123[2]-x123[3] )/(2-G)
z <- sum( c(x123,x4) )
p <- c( x123 , x4 )/z
list( H=-sum( p*log(p) ) , p=p )
}
H <- replicate( 1e5 , sim.p(1.4) )
plot(density( as.numeric(H[1,]) , adj=0.1 ))
sim.p <- function(G=1.4) {
x123 <- runif(3)
x4 <- ( (G)*sum(x123)-x123[2]-x123[3] )/(2-G)
z <- sum( c(x123,x4) )
p <- c( x123 , x4 )/z
list( H=-sum( p*log(p) ) , p=p )
}
H <- replicate( 1e5 , sim.p(1.4) )
plot(density( as.numeric(H[1,]) , adj=0.1 ), main = "", xlab = "Entropy")
entropies <- as.numeric(H[1,])
distributions <- H[2,]
max(entropies)
distributions[ which.max(entropies) ]
entropies <- as.numeric(H[1,])
distributions <- H[2,]
max(entropies)
distributions[ which.max(entropies) ]
# Theoretical maximum entropy distribution
p <- 0.7
-sum( A*log(A) )
entropies <- as.numeric(H[1,])
distributions <- H[2,]
max(entropies)
distributions[ which.max(entropies) ]
# Theoretical maximum entropy distribution
p <- 0.7
( A <- c( (1-p)^2 , p*(1-p) , (1-p)*p , p^2 ) )
-sum( A*log(A) )
entropies <- as.numeric(H[1,])
distributions <- H[2,]
distributions[ which.max(entropies) ]
max(entropies)
# Theoretical maximum entropy distribution
p <- 0.7
( A <- c( (1-p)^2 , p*(1-p) , (1-p)*p , p^2 ) )
-sum( A*log(A) )
blogdown:::serve_site()
blogdown:::serve_site()
