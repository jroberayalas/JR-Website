p_admit_female = invlogit(b_Intercept),
diff_admit     = p_admit_male - p_admit_female) %>%
summarise(`2.5%`  = quantile(diff_admit, probs = .025),
`50%`   = median(diff_admit),
`97.5%` = quantile(diff_admit, probs = .975))
d <-
d %>%
mutate(case = factor(1:12))
p_10.6 <-
fitted(m10.6) %>%
as_tibble() %>%
bind_cols(d)
d_text <-
d %>%
group_by(dept) %>%
summarise(case = mean(as.numeric(case)),
admit = mean(admit/applications) + .05)
ggplot(data = d, aes(x = case, y = admit/applications)) +
geom_pointrange(data = p_10.6,
aes(y = Estimate/applications,
ymin = `2.5%ile`/applications ,
ymax = `97.5%ile`/applications),
color = wes_palette("Moonrise2")[1],
shape = 1, alpha = 1/3) +
geom_point(color = wes_palette("Moonrise2")[2]) +
geom_line(aes(group = dept),
color = wes_palette("Moonrise2")[2]) +
geom_text(data = d_text,
aes(y = admit, label = dept),
color = wes_palette("Moonrise2")[2],
family = "serif") +
coord_cartesian(ylim = 0:1) +
labs(y = "Proportion admitted",
title = "Posterior validation check") +
theme(axis.ticks.x = element_blank())
m10.8 <-
brm(data = d, family = binomial,
admit | trials(applications) ~ 0 + dept,
prior = c(set_prior("normal(0, 10)", class = "b")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
m10.9 <-
brm(data = d, family = binomial,
admit | trials(applications) ~ 0 + dept + male ,
prior = c(set_prior("normal(0, 10)", class = "b")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
fixef(m10.9) %>% round(digits = 2)
m10.9$fit
#loos <- loo(m10.6, m10.7, m10.8, m10.9,
#            reloo = T,
#            cores = 2)
d <-
d %>%
mutate(case = factor(1:12))
p_10.9 <-
fitted(m10.9) %>%
as_tibble() %>%
bind_cols(d)
d_text <-
d %>%
group_by(dept) %>%
summarise(case = mean(as.numeric(case)),
admit = mean(admit/applications) + .05)
ggplot(data = d, aes(x = case, y = admit/applications)) +
geom_pointrange(data = p_10.9,
aes(y = Estimate/applications,
ymin = `2.5%ile`/applications ,
ymax = `97.5%ile`/applications),
color = wes_palette("Moonrise2")[1],
shape = 1, alpha = 1/3) +
geom_point(color = wes_palette("Moonrise2")[2]) +
geom_line(aes(group = dept),
color = wes_palette("Moonrise2")[2]) +
geom_text(data = d_text,
aes(y = admit, label = dept),
color = wes_palette("Moonrise2")[2],
family = "serif") +
coord_cartesian(ylim = 0:1) +
labs(y = "Proportion admitted",
title = "Posterior validation check") +
theme(axis.ticks.x = element_blank())
l_m10.6 <- LOO(m10.6)
library(loo)
pareto_k_table(l_m10.6)
plot(l_m10.6)
pareto_k_ids(l_m10.6, threshold = 1)
# l_m10.6_reloo <- LOO(m10.6, reloo = T)
# outcome and predictor almost perfectly associated
y <- c(rep(0, 10), rep(1, 10))
x <- c(rep(-1, 9), rep(1, 11))
b.good <-
brm(data = list(y = y, x = x), family = bernoulli,
y ~ 1 + x,
prior = c(set_prior("normal(0, 10)", class = "Intercept"),
set_prior("normal(0, 10)", class = "b")))
pairs(b.good,
off_diag_args = list(size = 1/10, alpha = 1/6))
library(rethinking)
data(Kline)
d <- Kline
detach(package:rethinking)
library(brms)
rm(Kline)
d <-
d %>%
mutate(log_pop = log(population),
contact_high = ifelse(contact == "high", 1, 0))
d
m10.10 <- brm(data = d, family = poisson,
total_tools ~ 1 + log_pop + contact_high + contact_high:log_pop,
prior = c(set_prior("normal(0, 100)", class = "Intercept"),
set_prior("normal(0, 1)", class = "b")),
iter = 3000, warmup = 1000, chains = 4, cores = 4)
print(m10.10)
post <-
posterior_samples(m10.10)
post %>%
select(-lp__) %>%
rename(b_interaction = `b_log_pop:contact_high`) %>%
cor() %>%
round(digits = 2)
# We'll set a renewed color theme
color_scheme_set(c(wes_palette("Moonrise2")[2],
wes_palette("Moonrise2")[1],
wes_palette("Moonrise2")[4],
wes_palette("Moonrise2")[2],
wes_palette("Moonrise2")[1],
wes_palette("Moonrise2")[1]))
post %>%
select(-lp__) %>%
rename(b_interaction = `b_log_pop:contact_high`) %>%
mcmc_intervals(prob = .5, prob_outer = .95) +
theme(axis.ticks.y = element_blank(),
axis.text.y = element_text(hjust = 0))
post <-
post %>%
mutate(lambda_high = exp(b_Intercept + b_contact_high + (b_log_pop + `b_log_pop:contact_high`)*8),
lambda_low = exp(b_Intercept + b_log_pop*8),
diff = lambda_high - lambda_low)
post %>%
summarise(sum = sum(diff > 0)/length(diff))
post %>%
ggplot(aes(x = diff)) +
geom_density(color = "transparent",
fill = wes_palette("Moonrise2")[1]) +
geom_vline(xintercept = 0, linetype = 2,
color = wes_palette("Moonrise2")[2]) +
scale_y_continuous(NULL, breaks = NULL) +
labs(x = "lambda_high - lambda_low")
# Intermediary tibbles for our the dot and line portoin of the plot
point_tibble <-
tibble(x = c(median(post$b_contact_high), min(post$b_contact_high)),
y = c(min(post$`b_log_pop:contact_high`), median(post$`b_log_pop:contact_high`)))
line_tibble <-
tibble(parameter = rep(c("b_contact_high", "b_log_pop:contact_high"), each = 2),
x = c(quantile(post$b_contact_high, probs = c(.025, .975)),
rep(min(post$b_contact_high), times = 2)),
y = c(rep(min(post$`b_log_pop:contact_high`), times = 2),
quantile(post$`b_log_pop:contact_high`, probs = c(.025, .975))))
# the plot
post %>%
ggplot(aes(x = b_contact_high, y = `b_log_pop:contact_high`)) +
geom_point(color = wes_palette("Moonrise2")[1],
size = 1/10, alpha = 1/10) +
geom_point(data = point_tibble,
aes(x = x, y = y)) +
geom_line(data = line_tibble,
aes(x = x, y = y, group = parameter)) +
labs(subtitle = "Neither parameter is conventionally “significant,” but together they imply\nthat contact rate consistently influences prediction.")
# no interaction
m10.11 <-
update(m10.10, formula = total_tools ~ 1 + log_pop + contact_high,
iter = 3000, warmup = 1000, chains = 4, cores = 4)
# no contact rate
m10.12 <-
update(m10.10, formula = total_tools ~ 1 + log_pop,
iter = 3000, warmup = 1000, chains = 4, cores = 4)
# no log-population
m10.13 <-
update(m10.10, formula = total_tools ~ 1 + contact_high,
iter = 3000, warmup = 1000, chains = 4, cores = 4)
# intercept only
m10.14 <-
update(m10.10, formula = total_tools ~ 1,
iter = 3000, warmup = 1000, chains = 4, cores = 4)
tibble(model = c("m10.10", "m10.11", "m10.12", "m10.13", "m10.14"),
waic  = c(w_m10.10$estimates[3, 1], w_m10.11$estimates[3, 1], w_m10.12$estimates[3, 1], w_m10.13$estimates[3, 1], w_m10.14$estimates[3, 1]),
se    = c(w_m10.10$estimates[3, 2], w_m10.11$estimates[3, 2], w_m10.12$estimates[3, 2], w_m10.13$estimates[3, 2], w_m10.14$estimates[3, 2])) %>%
ggplot() +
geom_pointrange(aes(x = reorder(model, -waic), y = waic,
ymin = waic - se,
ymax = waic + se,
color = model),
shape = 16) +
scale_color_manual(values = wes_palette("Moonrise2")[c(1, 2, 1, 1, 1)]) +
coord_flip() +
labs(x = NULL, y = NULL,
title = "WAIC") +
theme(axis.ticks.y = element_blank(),
legend.position = "none")
w_m10.10 <- waic(m10.10)
w_m10.11 <- waic(m10.11)
w_m10.12 <- waic(m10.12)
w_m10.13 <- waic(m10.13)
w_m10.14 <- waic(m10.14)
compare_ic(w_m10.10, w_m10.11, w_m10.12, w_m10.13, w_m10.14)
l_m10.6_reloo <- LOO(m10.6, reloo = T)
loos <- loo(m10.6, m10.7, m10.8, m10.9,
reloo = T,
cores = 2)
loos
l_m10.6 <- LOO(m10.6)
l_m10.6
l_m10.6_reloo <- LOO(m10.6, reloo = T)
l_m10.6_reloo
tibble(model = c("m10.10", "m10.11", "m10.12", "m10.13", "m10.14"),
waic  = c(w_m10.10$estimates[3, 1], w_m10.11$estimates[3, 1], w_m10.12$estimates[3, 1], w_m10.13$estimates[3, 1], w_m10.14$estimates[3, 1]),
se    = c(w_m10.10$estimates[3, 2], w_m10.11$estimates[3, 2], w_m10.12$estimates[3, 2], w_m10.13$estimates[3, 2], w_m10.14$estimates[3, 2])) %>%
ggplot() +
geom_pointrange(aes(x = reorder(model, -waic), y = waic,
ymin = waic - se,
ymax = waic + se,
color = model),
shape = 16) +
scale_color_manual(values = wes_palette("Moonrise2")[c(1, 2, 1, 1, 1)]) +
coord_flip() +
labs(x = NULL, y = NULL,
title = "WAIC") +
theme(axis.ticks.y = element_blank(),
legend.position = "none")
nd <-
tibble(log_pop = rep(seq(from = 6.5,
to = 13,
length.out = 50),
times = 2),
contact_high = rep(0:1, each = 50))
ppa_10.9 <-
pp_average(m10.10, m10.11, m10.12,
weights = "loo",
method = "fitted",
newdata = nd) %>%
as_tibble() %>%
bind_cols(nd)
ppa_10.9 %>%
ggplot(aes(x = log_pop,
group = contact_high)) +
geom_ribbon(aes(ymin = `2.5%ile`,
ymax = `97.5%ile`,
fill = contact_high),
alpha = 1/4) +
geom_line(aes(y = Estimate, color = contact_high)) +
geom_text(data = d,
aes(y = total_tools,
label = total_tools,
color = contact_high),
size = 3.5) +
coord_cartesian(xlim = c(7.1, 12.4),
ylim = c(12, 70)) +
labs(x = "log population",
y = "total tools",
subtitle = "Blue is the high contact rate and black is the low.") +
theme(legend.position = "none",
panel.border = element_blank())
nd <-
tibble(log_pop = rep(seq(from = 6.5,
to = 13,
length.out = 50),
times = 2),
contact_high = rep(0:1, each = 50))
ppa_10.9 <-
pp_average(m10.10, m10.11, m10.12,
weights = "loo",
method = "fitted",
newdata = nd) %>%
as_tibble() %>%
bind_cols(nd)
ppa_10.9 %>%
ggplot(aes(x = log_pop,
group = contact_high)) +
geom_ribbon(aes(ymin = `2.5%ile`,
ymax = `97.5%ile`,
fill = contact_high),
alpha = 1/4) +
geom_line(aes(y = Estimate, color = contact_high)) +
geom_text(data = d,
aes(y = total_tools,
label = total_tools,
color = contact_high),
size = 3.5) +
coord_cartesian(xlim = c(7.1, 12.4),
ylim = c(12, 70)) +
labs(x = "log population",
y = "total tools",
subtitle = "Blue is the high contact rate and black is the low. Notice that both trends curve\n dramatically upwards as log-population increases. The impact of contact rate can be seen by the distance\n between the blue and gray predictions. There is plenty of overlap, especially at low and high\n log-population values, where there are no islands with high contact rate.") +
theme(legend.position = "none",
panel.border = element_blank())
library(rethinking)
data(chimpanzees)
d <- chimpanzees
detach(package:rethinking)
rm(chimpanzees)
library(brms)
library(tidyverse)
glimpse(d)
library(wesanderson)
wes_palette("Moonrise1")
library(ggthemes)
library(bayesplot)
theme_set(theme_default() +
theme_tufte() +
theme(plot.background = element_rect(fill = wes_palette("Moonrise1")[3],
color = wes_palette("Moonrise1")[3])))
library(rethinking)
data(Kline)
d <- Kline
detach(package:rethinking)
library(brms)
rm(Kline)
d <-
d %>%
mutate(log_pop = log(population),
contact_high = ifelse(contact == "high", 1, 0))
d
d <-
d %>%
mutate(log_pop_c = log_pop - mean(log_pop))
m10.10.c <-
brm(data = d, family = poisson,
total_tools ~ 1 + log_pop_c + contact_high + contact_high:log_pop_c,
prior = c(set_prior("normal(0, 10)", class = "Intercept"),
set_prior("normal(0, 10)", class = "b")),
iter = 3000, warmup = 1000, chains = 4, cores = 4)
m10.10 <- brm(data = d, family = poisson,
total_tools ~ 1 + log_pop + contact_high + contact_high:log_pop,
prior = c(set_prior("normal(0, 100)", class = "Intercept"),
set_prior("normal(0, 1)", class = "b")),
iter = 3000, warmup = 1000, chains = 4, cores = 4)
print(m10.10)
# this helps us set our custom color scheme
color_scheme_set(c(wes_palette("Moonrise2")[3],
wes_palette("Moonrise2")[1],
wes_palette("Moonrise2")[2],
wes_palette("Moonrise2")[2],
wes_palette("Moonrise2")[1],
wes_palette("Moonrise2")[1]))
# the actual plot
mcmc_pairs(x = posterior_samples(m10.10),
pars = c("b_Intercept", "b_log_pop", "b_contact_high", "b_log_pop:contact_high"),
off_diag_args = list(size = 1/10, alpha = 1/10),
diag_fun = "dens")
mcmc_pairs(x = posterior_samples(m10.10.c),
pars = c("b_Intercept", "b_log_pop_c", "b_contact_high", "b_log_pop_c:contact_high"),
off_diag_args = list(size = 1/10, alpha = 1/10),
diag_fun = "dens")
print(m10.10.c)
print(m10.10)
set.seed(3838) # making it reproducible
num_days <- 30
y <- rpois(num_days, 1.5)
set.seed(3838) # making it reproducible
num_weeks <- 4
y_new <- rpois(num_weeks, 0.5*7)
d <-
tibble(y = c(y, y_new),
days = c(rep(1, 30), rep(7, 4)),
monastery = c(rep(0, 30), rep(1, 4)))
d
tail(d)
d <-
d %>%
mutate(log_days = log(days))
m10.15 <-
brm(data = d, family = poisson,
y ~ 1 + offset(log_days) + monastery,
prior = c(set_prior("normal(0, 100)", class = "Intercept"),
set_prior("normal(0, 1)", class = "b")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
posterior_samples(m10.15) %>%
mutate(lambda_old = exp(b_Intercept),
lambda_new  = exp(b_Intercept + b_monastery)) %>%
gather(key, value, -(b_Intercept:lp__)) %>%
mutate(key = factor(key, levels = c("lambda_old", "lambda_new"))) %>%
group_by(key) %>%
summarise(Mean = mean(value) %>% round(digits = 2),
StdDev = sd(value) %>% round(digits = 2),
LL = quantile(value, probs = .025) %>% round(digits = 2),
UL = quantile(value, probs = .975) %>% round(digits = 2))
posterior_samples(m10.15) %>%
mutate(lambda_old = exp(b_Intercept),
lambda_new  = exp(b_Intercept + b_monastery)) %>%
gather(key, value, -(b_Intercept:lp__))
posterior_samples(m10.15) %>%
mutate(lambda_old = exp(b_Intercept),
lambda_new  = exp(b_Intercept + b_monastery)) %>%
gather(key, value, -(b_Intercept:lp__))
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
detach(package:rethinking)
library(brms)
b10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
detach(package:rethinking)
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
detach(package:rethinking)
library(brms)
m10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
detach(package:rethinking)
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
detach(package:rethinking)
library(brms)
m10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
print(m10.16)
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
# fit the model, using dcategorical and softmax link
m10.16 <- map(
alist(career ~ dcategorical( softmax(0,s2,s3) ),
s2 <- b*2, # linear model for event type 2
s3 <- b*3, # linear model for event type 3
b ~ dnorm(0,5)
) ,
data=list(career=career) )
m10.16
softmax(0, 0.66, 0.99)
detach(package:rethinking)
library(brms)
m10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
print(m10.16)
