mutate(log_pop = log(population),
contact_high = ifelse(contact == "high", 1, 0))
d
d <-
d %>%
mutate(log_pop_c = log_pop - mean(log_pop))
m10.10.c <-
brm(data = d, family = poisson,
total_tools ~ 1 + log_pop_c + contact_high + contact_high:log_pop_c,
prior = c(set_prior("normal(0, 10)", class = "Intercept"),
set_prior("normal(0, 10)", class = "b")),
iter = 3000, warmup = 1000, chains = 4, cores = 4)
m10.10 <- brm(data = d, family = poisson,
total_tools ~ 1 + log_pop + contact_high + contact_high:log_pop,
prior = c(set_prior("normal(0, 100)", class = "Intercept"),
set_prior("normal(0, 1)", class = "b")),
iter = 3000, warmup = 1000, chains = 4, cores = 4)
print(m10.10)
# this helps us set our custom color scheme
color_scheme_set(c(wes_palette("Moonrise2")[3],
wes_palette("Moonrise2")[1],
wes_palette("Moonrise2")[2],
wes_palette("Moonrise2")[2],
wes_palette("Moonrise2")[1],
wes_palette("Moonrise2")[1]))
# the actual plot
mcmc_pairs(x = posterior_samples(m10.10),
pars = c("b_Intercept", "b_log_pop", "b_contact_high", "b_log_pop:contact_high"),
off_diag_args = list(size = 1/10, alpha = 1/10),
diag_fun = "dens")
mcmc_pairs(x = posterior_samples(m10.10.c),
pars = c("b_Intercept", "b_log_pop_c", "b_contact_high", "b_log_pop_c:contact_high"),
off_diag_args = list(size = 1/10, alpha = 1/10),
diag_fun = "dens")
print(m10.10.c)
print(m10.10)
set.seed(3838) # making it reproducible
num_days <- 30
y <- rpois(num_days, 1.5)
set.seed(3838) # making it reproducible
num_weeks <- 4
y_new <- rpois(num_weeks, 0.5*7)
d <-
tibble(y = c(y, y_new),
days = c(rep(1, 30), rep(7, 4)),
monastery = c(rep(0, 30), rep(1, 4)))
d
tail(d)
d <-
d %>%
mutate(log_days = log(days))
m10.15 <-
brm(data = d, family = poisson,
y ~ 1 + offset(log_days) + monastery,
prior = c(set_prior("normal(0, 100)", class = "Intercept"),
set_prior("normal(0, 1)", class = "b")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
posterior_samples(m10.15) %>%
mutate(lambda_old = exp(b_Intercept),
lambda_new  = exp(b_Intercept + b_monastery)) %>%
gather(key, value, -(b_Intercept:lp__)) %>%
mutate(key = factor(key, levels = c("lambda_old", "lambda_new"))) %>%
group_by(key) %>%
summarise(Mean = mean(value) %>% round(digits = 2),
StdDev = sd(value) %>% round(digits = 2),
LL = quantile(value, probs = .025) %>% round(digits = 2),
UL = quantile(value, probs = .975) %>% round(digits = 2))
posterior_samples(m10.15) %>%
mutate(lambda_old = exp(b_Intercept),
lambda_new  = exp(b_Intercept + b_monastery)) %>%
gather(key, value, -(b_Intercept:lp__))
posterior_samples(m10.15) %>%
mutate(lambda_old = exp(b_Intercept),
lambda_new  = exp(b_Intercept + b_monastery)) %>%
gather(key, value, -(b_Intercept:lp__))
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
detach(package:rethinking)
library(brms)
b10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
detach(package:rethinking)
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
detach(package:rethinking)
library(brms)
m10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
detach(package:rethinking)
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
detach(package:rethinking)
library(brms)
m10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
print(m10.16)
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
# fit the model, using dcategorical and softmax link
m10.16 <- map(
alist(career ~ dcategorical( softmax(0,s2,s3) ),
s2 <- b*2, # linear model for event type 2
s3 <- b*3, # linear model for event type 3
b ~ dnorm(0,5)
) ,
data=list(career=career) )
m10.16
softmax(0, 0.66, 0.99)
detach(package:rethinking)
library(brms)
m10.16 <-
brm(data = list(career = career),
family = categorical(link = "logit"),
career ~ 1,
prior = c(set_prior("normal(0, 5)", class = "Intercept")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
print(m10.16)
library(rethinking)
data(chimpanzees)
d <- chimpanzees
detach(package:rethinking)
rm(chimpanzees)
library(brms)
library(tidyverse)
glimpse(d)
library(rethinking)
data(chimpanzees)
d <- chimpanzees
detach(package:rethinking)
rm(chimpanzees)
library(brms)
library(tidyverse)
glimpse(d)
library(wesanderson)
wes_palette("Moonrise1")
library(ggthemes)
library(bayesplot)
theme_set(theme_default() +
theme_tufte() +
theme(plot.background = element_rect(fill = wes_palette("Moonrise1")[3],
color = wes_palette("Moonrise1")[3])))
detach(package:brms)
library(rethinking)
# simulate career choices among 500 individuals
N <- 500             # number of individuals
income <- 1:3        # expected income of each career
score <- 0.5*income  # scores for each career, based on income
# next line converts scores to probabilities
p <- softmax(score[1], score[2], score[3])
# now simulate choice
# outcome career holds event type values, not counts
career <- rep(NA, N)  # empty vector of choices for each individual
set.seed(2078)
# sample chosen career for each individual
for(i in 1:N) career[i] <- sample(1:3, size = 1, prob = p)
career %>%
as_tibble() %>%
ggplot(aes(x = value %>% as.factor())) +
geom_bar(size = 0, fill = wes_palette("Moonrise2")[2])
d
career
detach(package:brms)
library(rethinking)
N <- 100
set.seed(2078)
# simulate family incomes for each individual
family_income <- runif(N)
# assign a unique coefficient for each type of event
b <- (1:-1)
career <- rep(NA, N)  # empty vector of choices for each individual
for (i in 1:N) {
score <- 0.5*(1:3) + b*family_income[i]
p <- softmax(score[1], score[2], score[3])
career[i] <- sample(1:3, size = 1, prob = p)
}
career
detach(package:rethinking)
library(brms)
m10.17 <-
brm(data = list(career = career,
family_income = family_income),
family = categorical(link = "logit"),
career ~ 1 + family_income,
prior = c(set_prior("normal(0, 5)", class = "Intercept"),
set_prior("normal(0, 5)", class = "b")),
iter = 2500, warmup = 500, cores = 2, chains = 2)
print(m10.17)
# binomial model of overall admission probability
b_binom <-
brm(data = d, family = binomial,
admit | trials(applications) ~ 1,
prior = c(set_prior("normal(0, 100)", class = "Intercept")),
iter = 2000, warmup = 1000, cores = 3, chains = 3)
library(rethinking)
data(UCBadmit)
d <- UCBadmit
rm(UCBadmit)
detach(package:rethinking)
library(brms)
# binomial model of overall admission probability
b_binom <-
brm(data = d, family = binomial,
admit | trials(applications) ~ 1,
prior = c(set_prior("normal(0, 100)", class = "Intercept")),
iter = 2000, warmup = 1000, cores = 3, chains = 3)
# Poisson model of overall admission rate and rejection rate
d <-
d %>%
mutate(rej = reject) # 'reject' is a reserved word
b_pois <-
brm(data = d, family = poisson,
cbind(admit, rej) ~ 1,
prior = c(set_prior("normal(0, 100)", class = "Intercept")),
iter = 2000, warmup = 1000, cores = 3, chains = 3)
posterior_samples(b_pois) %>%
ggplot(aes(x = exp(b_admit_Intercept))) +
geom_density(fill = wes_palette("Moonrise2")[2], size = 0) +
geom_vline(xintercept = mean(d$admit), color = wes_palette("Moonrise2")[1]) +
scale_y_continuous(NULL, breaks = NULL) +
labs(x = "# applications",
title = "Mean acceptance # across departments:",
subtitle = "The density is the posterior distribution. The line is the\nvalue in the data.")
# binomial model of overall admission probability
m_binom <-
brm(data = d, family = binomial,
admit | trials(applications) ~ 1,
prior = c(set_prior("normal(0, 100)", class = "Intercept")),
iter = 2000, warmup = 1000, cores = 3, chains = 3)
# Poisson model of overall admission rate and rejection rate
d <-
d %>%
mutate(rej = reject) # 'reject' is a reserved word
m_pois <-
brm(data = d, family = poisson,
cbind(admit, rej) ~ 1,
prior = c(set_prior("normal(0, 100)", class = "Intercept")),
iter = 2000, warmup = 1000, cores = 3, chains = 3)
print(m_pois)
posterior_samples(m_pois) %>%
ggplot(aes(x = exp(b_admit_Intercept))) +
geom_density(fill = wes_palette("Moonrise2")[2], size = 0) +
geom_vline(xintercept = mean(d$admit), color = wes_palette("Moonrise2")[1]) +
scale_y_continuous(NULL, breaks = NULL) +
labs(x = "# applications",
title = "Mean acceptance # across departments:",
subtitle = "The density is the posterior distribution. The line is the\nvalue in the data.")
posterior_samples(m_pois) %>%
ggplot(aes(x = exp(b_rej_Intercept))) +
geom_density(fill = wes_palette("Moonrise2")[1], size = 0) +
geom_vline(xintercept = mean(d$rej), color = wes_palette("Moonrise2")[2]) +
scale_y_continuous(NULL, breaks = NULL) +
labs(x = "# applications",
title = "Mean rejection # across departments:",
subtitle = "The density is the posterior distribution. The line is the\nvalue in the data.")
fixef(b_binom) %>%
invlogit()
invlogit <- function(x){1/(1 + exp(-x))}
fixef(m10.1) %>%
invlogit()
fixef(b_binom) %>%
invlogit()
k <-
fixef(b_pois) %>%
as.numeric()
exp(k[1])/(exp(k[1]) + exp(k[2]))
# simulate
N <- 100
set.seed(1028)
x <- runif(N)
set.seed(1028)
y <- rgeom(N, prob = invlogit(-1 + 2*x))
list(y = y, x = x) %>%
as_tibble() %>%
ggplot(aes(x = x, y = y)) +
geom_point(size = 3/5, alpha = 2/3)
m10.18 <-
brm(data = list(y = y, x = x),
family = geometric(link = "log"),
y ~ 0 + intercept + x,
prior = c(set_prior("normal(0, 10)", class = "b", coef = "intercept"),
set_prior("normal(0, 1)", class = "b")),
chains = 2, iter = 2500, warmup = 500, cores = 2)
print(m10.18)
plot(marginal_effects(m10.18),
points = T,
point_args = c(size = 3/5, alpha = 2/3),
line_args = c(color = wes_palette("Moonrise2")[1],
fill = wes_palette("Moonrise2")[1]))
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::new_post_addin()
scales::show_col(canva_pal("Green fields")(4))
library(rethinking)
data(Trolley)
d <- Trolley
rm(Trolley)
detach(package:rethinking, unload = T)
library(brms)
library(ggthemes)
scales::show_col(canva_pal("Green fields")(4))
library(rethinking)
data(Trolley)
d <- Trolley
rm(Trolley)
detach(package:rethinking, unload = T)
library(brms)
library(ggthemes)
scales::show_col(canva_pal("Green fields")(4))
library(rethinking)
data(Trolley)
d <- Trolley
rm(Trolley)
detach(package:rethinking, unload = T)
library(brms)
library(ggthemes)
scales::show_col(canva_pal("Green fields")(4))
g
d
library(tidyverse)
hist_plot <- ggplot(data = d, aes(x = response, fill = ..x..)) +
geom_histogram(binwidth = 1/4, size = 0) +
scale_x_continuous(breaks = 1:7) +
theme_hc() +
scale_fill_gradient(low = canva_pal("Green fields")(4)[4],
high = canva_pal("Green fields")(4)[1]) +
theme(axis.ticks.x = element_blank(),
plot.background = element_rect(fill = "grey92"),
legend.position = "none")
cum_plot <- d %>%
group_by(response) %>%
count() %>%
mutate(pr_k = n/nrow(d)) %>%
ungroup() %>%
mutate(cum_pr_k = cumsum(pr_k)) %>%
ggplot(aes(x = response, y = cum_pr_k,
fill = response)) +
geom_line(color = canva_pal("Green fields")(4)[2]) +
geom_point(shape = 21, colour = "grey92",
size = 2.5, stroke = 1) +
scale_x_continuous(breaks = 1:7) +
scale_y_continuous(breaks = c(0, .5, 1)) +
coord_cartesian(ylim = c(0, 1)) +
labs(y = "cumulative proportion") +
theme_hc() +
scale_fill_gradient(low = canva_pal("Green fields")(4)[4],
high = canva_pal("Green fields")(4)[1]) +
theme(axis.ticks.x = element_blank(),
plot.background = element_rect(fill = "grey92"),
legend.position = "none")
# McElreath's convenience function
logit <- function(x) log(x/(1-x))
log_cum_odd_plot <- d %>%
group_by(response) %>%
count() %>%
mutate(pr_k = n/nrow(d)) %>%
ungroup() %>%
mutate(cum_pr_k = cumsum(pr_k)) %>%
filter(response < 7) %>%
# We can do the logit() conversion right in ggplot2
ggplot(aes(x = response, y = logit(cum_pr_k),
fill = response)) +
geom_line(color = canva_pal("Green fields")(4)[2]) +
geom_point(shape = 21, colour = "grey92",
size = 2.5, stroke = 1) +
scale_x_continuous(breaks = 1:7) +
coord_cartesian(xlim = c(1, 7)) +
labs(y = "log-cumulative-odds") +
theme_hc() +
scale_fill_gradient(low = canva_pal("Green fields")(4)[4],
high = canva_pal("Green fields")(4)[1]) +
theme(axis.ticks.x = element_blank(),
plot.background = element_rect(fill = "grey92"),
legend.position = "none")
library(gridExtra)
grid.arrange(hist_plot, cum_plot, log_cum_odd_plot, ncol=3)
d_plot <-
d %>%
group_by(response) %>%
count() %>%
mutate(pr_k = n/nrow(d)) %>%
ungroup() %>%
mutate(cum_pr_k = cumsum(pr_k))
ggplot(data = d_plot,
aes(x = response, y = cum_pr_k,
color = cum_pr_k, fill = cum_pr_k)) +
geom_line(color = canva_pal("Green fields")(4)[1]) +
geom_point(shape = 21, colour = "grey92",
size = 2.5, stroke = 1) +
geom_linerange(aes(ymin = 0, ymax = cum_pr_k),
alpha = 1/2, color = canva_pal("Green fields")(4)[1]) +
# There are probably more elegant ways to do this part.
geom_linerange(data = . %>%
mutate(discrete_probability = ifelse(response == 1, cum_pr_k, cum_pr_k - pr_k)),
aes(x = response + .025,
ymin = ifelse(response == 1, 0, discrete_probability),
ymax = cum_pr_k),
color = "black") +
geom_text(data = tibble(text        = 1:7,
response = seq(from = 1.25, to = 7.25, by = 1),
cum_pr_k = d_plot$cum_pr_k - .065),
aes(label = text),
size = 4) +
scale_x_continuous(breaks = 1:7) +
scale_y_continuous(breaks = c(0, .5, 1)) +
coord_cartesian(ylim = c(0, 1)) +
labs(y = "cumulative proportion") +
theme_hc() +
scale_fill_gradient(low = canva_pal("Green fields")(4)[4],
high = canva_pal("Green fields")(4)[1]) +
scale_color_gradient(low = canva_pal("Green fields")(4)[4],
high = canva_pal("Green fields")(4)[1]) +
theme(axis.ticks.x = element_blank(),
plot.background = element_rect(fill = "grey92"),
legend.position = "none")
# Here are our starting values, which we specify with the `inits` argument in brm()
Inits <- list(`Intercept[1]` = -2,
`Intercept[2]` = -1,
`Intercept[3]` = 0,
`Intercept[4]` = 1,
`Intercept[5]` = 2,
`Intercept[6]` = 2.5)
InitsList <-list(Inits, Inits)
m11.1 <-
brm(data = d, family = cumulative,
response ~ 1,
prior = c(set_prior("normal(0, 10)", class = "Intercept")),
iter = 2000, warmup = 1000, cores = 2, chains = 2,
inits = InitsList)  # Here we place our start values into brm()
print(m11.1)
head(d)
glimpse(d)
invlogit <- function(x) {1/(1+exp(-x))}
m11.1 %>%
fixef() %>%
invlogit()
